### Node多进程

Node.js提供了cluster模块和child_process模块创建子进程，从而提高CPU的利用率。

### 框架是如何工作的？

* 重新渲染整个组件[React]

当组件中的状态发生改变时，在内存中计算出(新的)DOM结构后与已有的DOM结构进行对比。实际上，这是非常昂贵的。因而采取(将真实DOM)映射为虚拟DOM，通过对比状态变化前后虚拟DOM的不同，计算出变化后再改变真实DOM结构。这个过程称为调和(reconciliation)。

* 通过(添加)观察者监测变化[Angular|Vue.js]

应用中状态的属性会被监测，当它们发生变化时，只有依赖了(发生变化)属性的DOM元素会被重新渲染。

### requestAnimationFrame

window.requestAnimationFrame()方法希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数，这个回调函数会在浏览器重绘之前调用。

* 优化并行的动画动作，更合理地重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。

* 解决毫秒的不精确性

* 避免过度渲染

### Webpack和Grunt的区别

Grunt构建工具更关注于过程，明确先做什么，再做什么。

Webpack模块化工具，更关注模块划分以及模块之间的依赖关系。

Webpack是一种模块化的解决方案，但由于其加载器(loaders)的存在，使webpack可以在打包之前，对原始文件做预处理。Webpack的处理过程：给定一个入口文件，从该文件开始找到项目的所有依赖，并用loaders处理这些文件，最后打包成可执行的JavaScript文件。

### 模块规范

#### CommonJS node.js

CommonJS加载模块是同步的，所以只有加载完成才能执行后面的操作。

#### ES6模块规范

ES6在编译时就能确定模块的依赖关系；CommonJS只能在运行时确定模块的依赖关系。

#### 浏览器段模块规范

AMD(异步模块定义)推崇依赖前置，在定义模块的时候就要声明其依赖的模块。

    提前执行 依赖前置 RequireJS

    AMD的一个AMD可以多用

CMD(通用模块定义)推崇就近依赖，只有在用到某个模块的时候再去require

    延迟执行 依赖就近 SeaJS

    CMD的API职责单一，没有全局require

AMD和CMD最大的区别是对依赖模块的执行时机处理不同

#### 跨平台的解决方案

UMD Common.js和AMD的熔合

UMD先判断是否支持Node.js的模块(exports)是否存在，存在则使用Node.js模块模式；判断是否支持AMD(define是否存在)，存在则使用AMD方式加载模块。