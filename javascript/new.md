### 框架是如何工作的？

* 重新渲染整个组件[React]

当组件中的状态发生改变时，在内存中计算出(新的)DOM结构后与已有的DOM结构进行对比。实际上，这是非常昂贵的。因而采取(将真实DOM)映射为虚拟DOM，通过对比状态变化前后虚拟DOM的不同，计算出变化后再改变真实DOM结构。这个过程称为调和(reconciliation)。

* 通过(添加)观察者监测变化[Angular|Vue.js]

应用中状态的属性会被监测，当它们发生变化时，只有依赖了(发生变化)属性的DOM元素会被重新渲染。

### requestAnimationFrame

window.requestAnimationFrame()方法希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数，这个回调函数会在浏览器重绘之前调用。

* 优化并行的动画动作，更合理地重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。

* 解决毫秒的不精确性

* 避免过度渲染

### Webpack和Grunt的区别

Grunt构建工具更关注于过程，明确先做什么，再做什么。

Webpack模块化工具，更关注模块划分以及模块之间的依赖关系。

Webpack是一种模块化的解决方案，但由于其加载器(loaders)的存在，使webpack可以在打包之前，对原始文件做预处理。Webpack的处理过程：给定一个入口文件，从该文件开始找到项目的所有依赖，并用loaders处理这些文件，最后打包成可执行的JavaScript文件。

### 模块规范

#### CommonJS node.js

CommonJS加载模块是同步的，所以只有加载完成才能执行后面的操作。

#### ES6模块规范

ES6在编译时就能确定模块的依赖关系；CommonJS只能在运行时确定模块的依赖关系。

#### 浏览器端模块规范

AMD(异步模块定义)推崇依赖前置，在定义模块的时候就要声明其依赖的模块。

    提前执行 依赖前置 RequireJS

    AMD的一个AMD可以多用

CMD(通用模块定义)推崇就近依赖，只有在用到某个模块的时候再去require

    延迟执行 依赖就近 SeaJS

    CMD的API职责单一，没有全局require

AMD和CMD最大的区别是对依赖模块的执行时机处理不同

#### 跨平台的解决方案

UMD Common.js和AMD的熔合

UMD先判断是否支持Node.js的模块(exports)是否存在，存在则使用Node.js模块模式；判断是否支持AMD(define是否存在)，存在则使用AMD方式加载模块。

### MVC MVP MVVM

参考链接：http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html

### 同步 异步

同步：必须一件一件事做，等前一件做完了才能做下一件事。

异步：发布事情命令就行，完事自行通知。

### AngularJS双向绑定

### gif, png, jpg

##### 有损vs无损

图片文件格式有可能会对图片的文件大小进行不同程度的压缩。

##### 索引色vs直接色

索引色: 用一个数字来代表(索引)一种颜色，在存储图片的时候，存储一个数字的组合，同时存储数字到图片颜色的映射。通常是256种颜色。

直接色: 使用四个数字来代表一种颜色，这四个数字分别代表这个颜色中红色、绿色、蓝色以及透明度。256*256*256*256=(2^8)*(2^8)*(2^8)*(2^8)=2^32

##### 点阵图vs矢量图

点阵图(位图|像素图):由像素队列的排列来实现其显示效果。

矢量图(向量图):尺量图记录了元素形状及颜色的算法。

BMP: 无损 索引色|直接色 点阵图

GIF: 无损 索引色 点阵图

JPEG: 有损 直接色 点阵图

PNG-8: 无损 索引色 点阵图

PNG-24: 无损 直接色 点阵图

SVG: 无损 矢量图

WebP: 有损|无损 直接色 点阵图

